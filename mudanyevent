#!/usr/bin/env perl
# vim: set filetype=perl :
use strict;
use warnings;

use lib './lib';

use EV;
use AnyEvent;
use AnyEvent::Socket;
use AnyEvent::Handle;
use Time::HiRes qw/tv_interval gettimeofday/;

use Av4::Telnet qw/%TELOPTS %TELOPTIONS TELOPT_FIRST
    TELOPT_WILL TELOPT_WONT TELOPT_DO TELOPT_DONT
    TELOPT_IAC TELOPT_SB TELOPT_SE TELOPT_COMPRESS2
    TELOPT_TTYPE TELOPT_NAWS TELOPT_MSP TELOPT_MXP
    _256col/;

my $quit_program = AnyEvent->condvar;

my $nclients = 0;
my %clients;

my %stats = (
    recv_bytes => 0,
    sent_bytes => 0,
);
my $t0 = [gettimeofday];

my $BANNER =<<'END';
In many MUDs commands are parsed and executed in a first-come first-served
fashion: if the character is currently performing an action which delays
(casting a spelli for example), any other command (including non-delaying
ones such as SCORE) need to wait for the first command to be executed.
In other mode modern MUDs there may be multiple command queues which allow
the player to perform delaying actions which don't overlap with each
other. For example, using an attack prevents the player from attacking
again before N seconds, but meanwhile the player can still ready a
defensive command or see their statistics.  Anacronia V4 implements a
queue system in which all the unknown commands are weeded out of the
command queue, and commands are executed in order of priority. Adding
specific queue types (attack, defense, movement) is on the roadmap and
should be fairly easy to implement.
END

#my $srv = tcp_server(undef, 8081, \&accept_cb, sub {
tcp_server(undef, 8081, \&accept_cb, sub {
    my ($fh, $thishost, $thisport) = @_;
    warn "Listening on $thishost:$thisport\n";
});

my $w = AnyEvent->signal(
    signal => "INT",
    cb     => sub {
        my $secs = tv_interval($t0,[gettimeofday]);
        print "\n\nShut down\n";
        print "Received $stats{recv_bytes} bytes - ".sprintf("%05.3f",$stats{recv_bytes}/$secs)." bytes/sec\n";
        print "Sent     $stats{sent_bytes} bytes - ".sprintf("%05.3f",$stats{sent_bytes}/$secs)." bytes/sec\n";
        print "Total run time: $secs seconds\n";
        exit 1;
    }
);

$quit_program->recv;

sub accept_cb
{
    my ($fh, $host, $port) = @_;
    my $curr_client = $nclients;
    warn "Connection from $host:$port ($curr_client)\n";
    my $handle;
    $handle = new AnyEvent::Handle(
        fh => $fh,
        on_error => sub {
            warn "Error $_[2]";
            $_[0]->destroy();
        },
        on_eof => sub {
            warn "Goodbye client $curr_client\n";
            delete $clients{$curr_client};
            $handle->destroy; # destroy handle
        },
    );
    $clients{$curr_client} = $fh;

    $handle->push_write( sprintf( "%c%c%c", TELOPT_IAC, TELOPT_WILL, TELOPT_COMPRESS2 ) );
    $handle->push_write( sprintf( "%c%c%c", TELOPT_IAC, TELOPT_DO,   TELOPT_TTYPE ) );
    $handle->push_write( sprintf( "%c%c%c", TELOPT_IAC, TELOPT_DO,   TELOPT_NAWS ) );
    $handle->push_write( sprintf( "%c%c%c", TELOPT_IAC, TELOPT_WILL, TELOPT_MSP ) );
    $handle->push_write( sprintf( "%c%c%c", TELOPT_IAC, TELOPT_WILL, TELOPT_MXP ) );
    $handle->push_write( '#$#mcp version: 2.1 to: 2.1' . "\r\n" );
    $handle->push_write("Hi, Welcome to the MUD!\r\n\r\n"); # FIXME BANNER

    $handle->on_read( sub {
            $stats{recv_bytes} += length $_[0]->rbuf;
            # print "($curr_client) Got: [", join(' ',map { sprintf("(%c(%d))",$_>=32&&$_<=126?$_:126,$_) } unpack('C*',$_[0]->rbuf)), "]\n";
            $handle->push_write($_[0]->rbuf);
            $handle->push_write($BANNER);
            $stats{sent_bytes} += length $_[0]->rbuf;
            $stats{sent_bytes} += length $BANNER;
            $_[0]->rbuf = '';
        });
    $nclients++;
    ();
}
